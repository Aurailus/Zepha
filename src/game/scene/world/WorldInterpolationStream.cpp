//
// Created by aurailus on 16/03/19.
//

#include "WorldInterpolationStream.h"

#pragma clang diagnostic push
#pragma ide diagnostic ignored "OCUnusedGlobalDeclarationInspection"

WorldInterpolationStream::WorldInterpolationStream(unsigned int seed) : gen(seed) {
    queuedTasks.reserve(1024);

    threads.reserve(THREADS);
    for (int i = 0; i < THREADS; i++) {
        threads.emplace_back(&gen);
    }
}

bool WorldInterpolationStream::pushBack(Packet *p) {
    queuedTasks.push_back(p);
}

std::vector<std::shared_ptr<BlockChunk>> WorldInterpolationStream::update() {
    std::vector<std::shared_ptr<BlockChunk>> finishedChunks;

    for (auto& t : threads) {
        for (auto& u : t.tasks) {
            if (!u.unlocked) continue;

            if (u.chunk != nullptr) {
                finishedChunks.push_back(std::shared_ptr<BlockChunk>(u.chunk));
                u.chunk = nullptr;
            }

            if (!queuedTasks.empty()) {
                auto it = queuedTasks.begin();
                Packet* p = *it;
                queuedTasks.erase(it);

                if (p == nullptr) {
                    cerr << "NULL PACKET IN THE WORLD INTERPOLATION STREAM! (" << __LINE__ << ")" << std::endl;
                    continue;
                }

                u.packet = p;
                //Lock it to allow the thread to edit it.
                u.unlocked = false;
            }
        }
    }

    return finishedChunks;
}

WorldInterpolationStream::Thread::Thread(MapGen *gen) {
    this->gen = gen;

    thread = std::thread(WorldInterpolationStream::threadFunction, this);
}

void WorldInterpolationStream::threadFunction(WorldInterpolationStream::Thread *thread) {

    while (thread->keepAlive) {

        bool empty = true;
        for (Unit& u : thread->tasks) {
            if (!u.unlocked) {

                //TODO: This entire thing is a mess.
                //The BlockChunks need a way to access the vector raw, deserialization needs to be abstracted,
                //It's two sepeare functions right now which is bad, and it might be possible to reduce the amount
                //of blocks generated by only generating ones not in the packet but it might not be worth it.

                empty = false;

                glm::vec3 pos = glm::vec3(
                        Serializer::decodeInt(&u.packet->data[0]),
                        Serializer::decodeInt(&u.packet->data[4]),
                        Serializer::decodeInt(&u.packet->data[8]));

                int len = Serializer::decodeInt(&u.packet->data[12]);

                std::string data(u.packet->data.begin() + 16, u.packet->data.begin() + 16 + len);
//                auto deserialized = BlockChunk::deserializeToVec(data);

//                u.chunk = thread->gen->generate(pos);

                u.chunk = new BlockChunk;
                u.chunk->pos = pos;
                bool success = u.chunk->deserialize(data);
//
//                glm::vec3 blockPos;
//                for (int i = 0; i < 4096; i++) {
//                    if (deserialized[i] != -1) {
//
//                        ArrayTrans3D::indAssignVec(i, blockPos);
//                        u.chunk->setBlock(&blockPos, deserialized[i]);
//
//                    }
//                }

                u.unlocked = true;

                delete u.packet;
                u.packet = nullptr;

                break;
            }
        }

        if (empty) {
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    }
}

WorldInterpolationStream::~WorldInterpolationStream() {
    for (auto& t : threads) {
        t.keepAlive = false;
        t.thread.join();
    }
}

#pragma clang diagnostic pop